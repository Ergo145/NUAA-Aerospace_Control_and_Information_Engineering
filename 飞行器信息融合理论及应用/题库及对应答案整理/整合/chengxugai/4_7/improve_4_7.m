clear all;      % 清除工作区中的所有变量
close all;      % 关闭所有图形窗口

% ========== 参数设置 ==========
T = 0.1;        % 采样时间间隔
a = 2e-4;       % 系统参数（衰减系数）
k = 0.5;        % 系统参数（增益系数）
rk1 = 0.1;      % 传感器1的测量噪声标准差
rk2 = 1;        % 传感器2的测量噪声标准差
N = 1000;       % 总采样点数

% ========== 状态方程参数计算 ==========
phik = exp(-a*T);           % 状态转移矩阵（离散时间系统）
Cx = k*(1-exp(-2*a*T));     % 过程噪声的方差
qk = sqrt(Cx);              % 过程噪声的标准差

% ========== 生成过程噪声 ==========
wn = randn(N,1);            % 生成N个标准正态分布的随机数
Wk = qk * wn;               % 生成过程噪声序列

% ========== 生成真实状态序列 ==========
xk = zeros(N,1);            % 初始化状态向量
xk(1,1) = Wk(1,1);          % 初始状态（第一个状态值）
for i = 2:N
    % 状态更新：x(k) = phi * x(k-1) + w(k)
    xk(i,1) = phik * xk(i-1,1) + Wk(i,1);
end

% ========== 生成传感器1的观测数据 ==========
vn = randn(N,1);            % 生成新的标准正态分布随机数
vk1 = rk1 * vn;             % 传感器1的测量噪声
zk1 = xk + vk1;             % 传感器1的观测值（真实状态+噪声）

% ========== 生成传感器2的观测数据 ==========
vn = randn(N,1);            % 再次生成标准正态分布随机数
vk2 = rk2 * vn;             % 传感器2的测量噪声
zk2 = xk + vk2;             % 传感器2的观测值（真实状态+噪声）

% ========== 估计器参数设置 ==========
h = [1; 1];                 % 观测矩阵（两个传感器对同一状态的观测）
R = [rk1^2 0; 0 rk2^2];     % 测量噪声协方差矩阵（对角矩阵）
zk = [zk1, zk2];            % 组合两个传感器的观测数据
R_inv = inv(R);             % 测量噪声协方差矩阵的逆

% ========== 加权递推最小二乘估计 ==========
wk = R_inv;                 % 权重矩阵（使用噪声协方差逆矩阵）
x_est_wls(1,1) = 0;         % 初始化加权最小二乘估计值
p_est_wls(1) = 1e6;         % 初始化估计误差协方差（设置较大初始值）
% 第一步更新：计算初始时刻的后验估计和协方差
p_est_wls(1) = 1/(1/p_est_wls(1) + h' * wk * h);
x_est_wls(1,1) = x_est_wls(1,1) + p_est_wls(1) * h' * wk * (zk(1,:)' - h * x_est_wls(1,1));

% 循环进行递推估计
for i = 2:N
    % 更新估计误差协方差
    p_est_wls(i) = 1/(1/p_est_wls(i-1) + h' * wk * h);
    % 更新状态估计值
    x_est_wls(i,1) = x_est_wls(i-1,1) + p_est_wls(i) * h' * wk * (zk(i,:)' - h * x_est_wls(i-1,1));
end

% ========== 最小方差估计（方法1：直接计算） ==========
% 计算最小方差估计的增益矩阵
Kk = Cx * h' * inv(h * Cx * h' + R);
% 对每个时刻进行最小方差估计
for i = 1:N
    x_est_mv(i,1) = Kk * zk(i,:)';    % 使用固定增益进行估计
end

% ========== 最小方差估计（方法2：递推形式） ==========
x_est_mv1(1,1) = 0;         % 初始化最小方差估计值
p_est_mv1(1) = 1e6;         % 初始化估计误差协方差
% 第一步更新：计算初始时刻的后验估计和协方差
p_est_mv1(1) = 1/(1/Cx + h' * R_inv * h);
x_est_mv1(1,1) = x_est_mv1(1,1) + p_est_mv1(1) * h' * R_inv * (zk(1,:)' - h * x_est_mv1(1,1));

% 循环进行递推估计
for i = 2:N
    % 更新估计误差协方差（使用矩阵求逆）
    p_est_mv1(i) = inv(inv(p_est_mv1(i-1)) + h' * R_inv * h);
    % 更新状态估计值
    x_est_mv1(i,1) = x_est_mv1(i-1,1) + p_est_mv1(i) * h' * R_inv * (zk(i,:)' - h * x_est_mv1(i-1,1));
end

% ========== 结果可视化 ==========
t = (0:N-1) * T;    % 生成时间向量

% 图1：状态估计结果对比
figure(1)
plot(t, xk, 'b-', t, x_est_wls, 'r*-', t, x_est_mv1, 'ko-');
xlabel('时间(s)'); ylabel('估计值');
legend('真值', '加权递推最小二乘估计', '最小方差估计');
title('状态估计结果对比');

% 图2：估计误差对比
figure(2)
plot(t, x_est_wls - xk, 'r*-', t, x_est_mv1 - xk, 'ko-');
xlabel('时间(s)'); ylabel('估计偏差');
legend('加权递推最小二乘估计误差', '最小方差估计误差');
title('估计误差对比');

% 图3：估计误差协方差对比
figure(3)
plot(t, p_est_wls, 'r*-', t, p_est_mv1, 'ko-');
xlabel('时间(s)'); ylabel('P');
legend('加权递推最小二乘估计', '最小方差估计');
title('估计误差协方差对比');