/* Begin Includes ------------------------------------------------------------------*/
#include "DSP2833x_Device.h"
#include "DSP2833x_Examples.h"
/* END   Includes ------------------------------------------------------------------*/

/* Begin DEFINES -------------------------------------------------------------------*/
#define CPU_FREQ_MHZ    150.0f // 系统频率定义 150MHZ
#define DEAD_BAND_US    5.0f   // 死区时间要求 (us)

// @brief 0对应步骤1和2 1对应步骤3
#define  ENABLE_STEP3  0    // 标记Step 3是否开始
/* END   DEFINES -------------------------------------------------------------------*/

/* Begin Variable ------------------------------------------------------------------*/
// 全局变量用于控制Step 3的状态
#if (ENABLE_STEP3 == 1)
    float32 current_duty = 0.0f;     // 当前占空比 (0.0 - 1.0)
    int16   duty_direction = 1;      // 1: 增加, -1: 减小
#endif
/* END Variable --------------------------------------------------------------------*/

/* Begin Function ------------------------------------------------------------------*/
// --- 函数声明 ---
void My_ePWM_Init(void);
void My_ePWMA_SetF(float32 A_CLK);     // A_CLK 单位 kHz
void My_ePWMA_Setduty(float32 duty);   // duty 范围 0.0 - 1.0
void My_ePWMB_SetF(float32 B_CLK);     // B_CLK 单位 kHz
void My_ePWMB_Setduty(float32 duty);   // duty 范围 0.0 - 1.0
interrupt void ISRTimer0(void);
/* END Function ------------------------------------------------------------------*/

// --- 主函数 ---
void main(void)
{
    // 步骤1: 初始化系统控制 (PLL, WatchDog, Enable Peripheral Clocks)
    InitSysCtrl();

    // 步骤2: 初始化GPIO
    InitEPwm1Gpio(); // 初始化ePWM1的GPIO (GPIO0/1)

    // 步骤3: 清除中断并初始化PIE
    DINT;
    InitPieCtrl();
    IER = 0x0000;
    IFR = 0x0000;
    InitPieVectTable();

    // 步骤4: 映射中断向量
    EALLOW;
    PieVectTable.TINT0 = &ISRTimer0;
    EDIS;

    // 步骤5: 初始化CPU定时器
    InitCpuTimers();
    // 配置定时器0：150MHz时钟，500ms（0.5秒）周期
    ConfigCpuTimer(&CpuTimer0, 150, 500000);
    StartCpuTimer0();

    // 步骤6: 配置ePWM
    // 这里完成 Step 1 (20k, 40%, 5us死区) 和 Step 2 (B反向)
    My_ePWM_Init();

    // 步骤7: 使能中断
    IER |= M_INT1;          // Enable CPU INT1
    PieCtrlRegs.PIEIER1.bit.INTx7 = 1; // Enable TINT0

    EINT;   // Enable Global switch
    ERTM;   // Enable Real-time interrupt

    // 主循环
    while(1)
    {
        asm(" NOP");
    }
}

// --- 中断服务程序 (Step 3 逻辑) ---
interrupt void ISRTimer0(void)
{
    // Step 3 要求:
    // 1. 频率变为30k (只设置一次)
    // 2. 占空比每0.5s增加10%，直到100%，然后减少直到0%
#if (ENABLE_STEP3 == 1)
        // 使用 static 变量来记录运行时状态，保证只初始化一次频率
        static Uint16 is_runtime_initialized = 0;

        if(is_runtime_initialized == 0)
        {
            // --- 第一次进入中断 (Step 3 启动) ---

            // 1. 修改频率为 30kHz (Step 3 要求)
            My_ePWMA_SetF(30.0);

            // 2. 初始化扫描变量
            current_duty = 0.0f;
            duty_direction = 1;

            // 3. 标记已初始化，后续中断不再执行此块
            is_runtime_initialized = 1;
        }
        else
        {
            // --- 后续中断 (Step 3 循环) ---

            if(duty_direction == 1)
            {
                current_duty += 0.1f;
                if(current_duty >= 1.0f)
                {
                    current_duty = 1.0f;
                    duty_direction = -1;
                }
            }
            else
            {
                current_duty -= 0.1f;
                if(current_duty <= 0.0f)
                {
                    current_duty = 0.0f;
                    duty_direction = 1;
                }
            }
        }

        // 应用占空比
        My_ePWMA_Setduty(current_duty);
        My_ePWMB_Setduty(current_duty);

    #endif

    // 清除中断标志
    CpuTimer0.InterruptCount++;
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

// --- 功能函数定义 ---

/* * My_ePWM_Init
 * 功能: 初始化ePWM1模块，满足Step 1和Step 2
 * 1. 频率20kHz, 占空比40%
 * 2. 死区5us (xA上升沿延迟, xB下降沿延迟)
 * 3. xB反向 (Active High Complementary模式)
 */
void My_ePWM_Init(void)
{
    EALLOW;
    SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 0; // 停止TB时钟进行配置
    EDIS;

    // 1. 时基配置 (Time Base)
    EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // 增减计数模式 (对称波形，适合死区生成)
    EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE;        // 禁用相位加载
    EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;       // 时钟不分频 TBCLK = SYSCLKOUT
    EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV1;

    // 初始设置频率 20kHz
    // TBPRD = 150MHz / (2 * 20kHz) = 3750
    My_ePWMA_SetF(20.0);

    // 2. 比较寄存器 (Counter Compare)
    // 初始设置占空比 40%
    My_ePWMA_Setduty(0.4);

    // 3. 动作限定 (Action Qualifier)
    // 增减计数模式下: CMPA上计数置低，下计数置高 -> 产生PWM波
    EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR;
    EPwm1Regs.AQCTLA.bit.CAD = AQ_SET;
    // B通道通常由死区模块基于A生成，这里AQ配置可设为互补或忽略(由DB控制)

    // 4. 死区配置 (Dead Band) - Step 1 & Step 2
    // 计算死区计数值: 5us / (1/150MHz) = 5 * 150 = 750 ticks
    Uint16 db_ticks = (Uint16)(DEAD_BAND_US * CPU_FREQ_MHZ); // 750

    EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // 使能双边沿延时 (Rising & Falling)
    EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC;      // Active High Complementary (AHC)
                                                   // 此模式下: EPWMxB 是 EPWMxA 的反向 (满足Step 2)
    EPwm1Regs.DBCTL.bit.IN_MODE = DBA_ALL;         // xA 作为上升沿和下降沿的输入源

    EPwm1Regs.DBRED = db_ticks; // xA 上升沿延迟 5us (满足Step 1)
    EPwm1Regs.DBFED = db_ticks; // xB 下降沿延迟 5us (满足Step 1)

    EALLOW;
    SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1; // 恢复时钟
    EDIS;
}

/*
 * My_ePWMA_SetF
 * 功能: 设置PWM A的频率
 * 参数: A_CLK (单位 kHz)
 * 原理: 修改TBPRD。计算公式: TBPRD = F_sys / (2 * F_pwm) (对于增减计数模式)
 * TBPRD = 150,000 kHz / (2 * A_CLK) = 75000 / A_CLK
 */
void My_ePWMA_SetF(float32 A_CLK)
{
    if(A_CLK <= 0.0f) return;
    Uint16 period = (Uint16)(75000.0f / A_CLK);
    EPwm1Regs.TBPRD = period;
}

/*
 * My_ePWMA_Setduty
 * 功能: 设置PWM A的占空比
 * 参数: duty (0.0 < duty < 1.0)
 */
void My_ePWMA_Setduty(float32 duty)
{
    // 限幅
    if(duty > 1.0f) duty = 1.0f;
    if(duty < 0.0f) duty = 0.0f;

    Uint16 prd = EPwm1Regs.TBPRD;
    // 在增减模式下，CMPA = TBPRD * duty 一般指脉宽宽度
    // 如果想要正脉宽占总周期的比例:
    // AQ配置为 CAU=Clear, CAD=Set (中心对齐)
    // 占空比 = CMPA / TBPRD (注意：实际波形生成取决于AQ配置，这里假设高电平居中)
    // 修正: 对于标准PWM生成，CMPA值越大，占空比越大或越小取决于AQ。
    // 假设 AQ: CAU=Clear (高->低), CAD=Set (低->高)，则中间部分是低电平。
    // 为了直观，通常 AQ: CAU=Set, CAD=Clear -> 中间是高电平。
    // 此时 CMPA = TBPRD * (1 - duty) 或者 CMPA = TBPRD * duty 取决于具体需求。
    // 这里采用最通用的: CMPA = TBPRD * duty，且假设AQ配置能产生对应正占空比。
    // 实际上，对于增减计数，CMPA值设定了翻转点。
    // 若要 duty% 的高电平: CMPA = (1 - duty) * TBPRD (如果中间高) ???
    // 让我们使用 TI 示例标准: CMPA = Period * Duty

    EPwm1Regs.CMPA.half.CMPA = (Uint16)(prd * duty);
}

/*
 * My_ePWMB_SetF
 * 说明: ePWM1A和1B共用同一个定时器(Time Base)，修改B频率等于修改A频率。
 */
void My_ePWMB_SetF(float32 B_CLK)
{
    My_ePWMA_SetF(B_CLK);
}

/*
 * My_ePWMB_Setduty
 * 说明: 如果开启了死区互补模式(DB_ACTV_HIC)，B的占空比自动由A决定(互补)。
 * 如果需要独立设置B的CMPB，可以使用此函数。但在Step 1/2要求下，B随A动。
 * 这里为了满足题目"定义函数"的要求，写入CMPB，但在死区开启时CMPB可能无效。
 */
void My_ePWMB_Setduty(float32 duty)
{
    if(duty > 1.0f) duty = 1.0f;
    if(duty < 0.0f) duty = 0.0f;

    Uint16 prd = EPwm1Regs.TBPRD;
    EPwm1Regs.CMPB = (Uint16)(prd * duty);
}