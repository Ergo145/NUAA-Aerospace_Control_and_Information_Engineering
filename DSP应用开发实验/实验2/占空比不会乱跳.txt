#include "DSP2833x_Device.h"
#include "DSP2833x_Examples.h"

// 补充有符号类型定义
typedef signed char int8;
typedef signed int int16;
typedef signed long int32;

// 全局变量：改用int类型避免溢出
int g_DutyCycle = 0;     // 初始占空比40%（用int防止溢出）
int8 g_DutyDir = 1;       // 1=增加，-1=减少

// 定时器0中断服务函数：精准控制占空比
interrupt void cpu_timer0_isr(void)
{
    // 1. 调整占空比（每次±10%）
    g_DutyCycle += g_DutyDir * 10;

    // 2. 严格边界限制（强制0~100）
    if(g_DutyCycle > 100)
    {
        g_DutyCycle = 100;
        g_DutyDir = -1;
    }
    else if(g_DutyCycle < 0)
    {
        g_DutyCycle = 0;
        g_DutyDir = 1;
    }

    // 3. 计算CMPA：用浮点运算保证精度（避免整数除法误差）
    float duty_ratio = (float)g_DutyCycle / 100.0f;
    Uint16 cmpa_val = (Uint16)(EPwm1Regs.TBPRD * duty_ratio);

    // 4. 更新CMPA（确保在合法范围）
    EALLOW;
    EPwm1Regs.CMPA.half.CMPA = cmpa_val;
    EDIS;

    // 5. 清除中断标志（必须按顺序）
    CpuTimer0Regs.TCR.bit.TIF = 1;           // 先清定时器中断标志
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;  // 再确认PIE中断
}

// ePWM1初始化：精准30kHz（核心修正）
void EPWM1_Init(void)
{
    EALLOW;
    SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 0;   // 关时钟同步
    EDIS;

    // 核心修正：增计数模式下30kHz的TBPRD计算
    // 公式：TBPRD = 系统时钟 / (目标频率 * 分频系数)
    // 150MHz / (30kHz * 1*1) = 5000 → TBPRD=5000
    EPwm1Regs.TBPRD = 5000;
    EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;  // 保持增计数（稳定）
    EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;    // 高频时钟不分频
    EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV1;       // 基础时钟不分频
    EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE;     // 禁止相位加载

    // 比较寄存器+动作限定（按新TBPRD初始化40%占空比）
    EPwm1Regs.CMPA.half.CMPA = 5000 * 0.4f;  // 初始CMPA=2000（40%占空比）
    EPwm1Regs.AQCTLA.bit.ZRO = AQ_SET;       // 计数到0时，输出高
    EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR;     // 计数到CMPA时，输出低

    EALLOW;
    SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1;   // 开时钟同步
    EDIS;
}


void CpuTimer0_Init(void)
{
    InitCpuTimers();
    ConfigCpuTimer(&CpuTimer0, 150, 5000000);
    CpuTimer0Regs.TCR.bit.TIE = 1;  // 使能中断
    CpuTimer0Regs.TCR.bit.TSS = 0;  // 启动定时器
}


void Interrupt_Init(void)
{
    DINT;
    InitPieCtrl();
    IER = 0x0000;
    IFR = 0x0000;
    InitPieVectTable();

    EALLOW;
    PieVectTable.TINT0 = &cpu_timer0_isr;
    EDIS;

    PieCtrlRegs.PIEIER1.bit.INTx7 = 1;
    IER |= M_INT1;
    EINT;
    ERTM;
}

// GPIO初始化（保持）
void GPIO_Init(void)
{
    EALLOW;
    GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1;  // GPIO0→ePWM1A
    GpioCtrlRegs.GPADIR.bit.GPIO0 = 1;
    EDIS;
}

void main(void)
{
    InitSysCtrl();
    DINT;
    InitPieCtrl();
    IER = 0x0000;
    IFR = 0x0000;
    InitPieVectTable();

    GPIO_Init();
    EPWM1_Init();
    CpuTimer0_Init();
    Interrupt_Init();

    while(1)
    {
        // 主循环空转（中断处理占空比）
    }
}